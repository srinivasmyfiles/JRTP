----------------------------------------------------------------
@Test : To represent method as Junit method

@BeforeClass    : To execute method before first test case execution

@AfterClass : To execute method after last test case execution

@Ignore : To skip method from current execution

-> For business class methods we are going to write Junit methods

-> For one business method we can write multiple unit  test methods

-> When we are performing Unit testing, sometime we need to except Exceptions from target class method.

-> When we are expecting an exception, we will use expected attribute in @Test annoation

-----------------------------------------------------------------
public Integer div(Integer a, Integer b) {
		return a / b;
}
----------------------------------------------------------------
@Test(expected = ArithmeticException.class)
public void testDiv_02() {
		calc.div(10, 0);
}
---------------------------------

-> We can use timeout attribute in @Test annotation

-> timeout attribute is used check target method execution completing within given amount of time or not

-> If target method execution is taking more time than given value then then it will be terminated abnormally


@Test(timeout = 1000)
public void testDiv_03() {
		calc.div(10, 2);
}




Unit Testing in Realtime Project
--------------------------------
-> In Realtime every application will be developed using MVC architecture

-> IN application we will have below layers

		a) Data Acces Layer (DAO)

		b) Business/ServiceLayer

		c) Web Layer

		d) UI layer


 -> JUnit we can use only to perform java classes unit testing

 Note : We can't use Junit for jsp testing
____________________________________________________________________________________________
What is Mocking?
Why we need mocking?
What are the Mock frameworks available?
Unit testing using mock frameworks

Mocking is a process of creating substitube object for real object

Mocking is very important as part of Unit testing

To test our component in isolated manner we will use Mocking

There are 2 types mock frameworks are available

	1)Proxy Based (Ex: Easy Mock, Mockito)

	2)Byte Code Manipulation (Ex: PowerMock & JMockit)

When we are developing an application, we will use layered architecture (MVC) 

In application we will be having below layers
---------------------------------------------
1) presentation layer   (User interface compoents)
2) web layer (Controller components)
3) business layer (Service components)
4) persistence layer (Dao components)

In the above four layer, we are going to use Junit to test last 3 layers code.

Note : We can't test Presentation components by using JUnit




In Project 2 developers are working

John and Smith

John is working on a story called HIS-134
Smith is working on a story called HIS-135

John changes are related to service class method impl
Smith changes are related to dao class method impl

John completed his service layer method implementation
Smith changes are not yet completed for dao impl

Can John perform Unit testing for his changes or not?
-----------------------------------------------------
No, he can't perform because john implemented code is dependent on dao method implementation which is not yet ready.

Options available for john
--------------------------
-> complete dao method implementation
-> wait for smith to complete dao implementation

Note : In this situation John has to use mocking

Mocking is the process of creating substitute/alternate object for real object.

Mocking is the process of imitating something

When to use Mocking
-------------------
1) If dependent components are not ready

2) To isolate our component for unit testing

There are several mock frameworks available in market
-----------------------------------------------------
Mock frameworks are categorized into 2 types

1) Proxy Based Mock Frameworks
	Ex : Easy Mock and Mockito

2) Byte Code Manipulation Based Mock Frameworks
	Ex : Power Mock and JMockito	

Limitations of Proxy Based Frameworks
-------------------------------------
-> Doesn't support for private methods mocking

-> Doesn't support for final methods mocking

-> Doens't support for static methods mocking

-> Doesn't support for final class mocking

To avoid the above limitations we are going to use Byte Code Manipulation Based Mock Frameworks.


Steps to develop application using Junit and EasyMock
-----------------------------------------------------
Junit ---> Unit Testing Framework

EasyMock ---> To perform Mocking

1) Create simple maven project

2) Add below dependencies in pom.xml file
	1) Junit
	2) EasyMock

3) Create Dao interface (only interface no implemenation)
    (required methods we will create as abstract)

4) Create Service interface & implementation
     (as part service method we will call dao method)

5) Create Unit test class for Service class using JUnit




Dependencies
------------
<dependencies>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>4.13</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.easymock</groupId>
			<artifactId>easymock</artifactId>
			<version>4.1</version>
			<scope>test</scope>
		</dependency>
</dependencies>